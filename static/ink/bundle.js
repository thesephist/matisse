
f = format;
Pi = (() => {let __ink_acc_trgt = __as_ink_string(Math); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[PI] || null : (__ink_acc_trgt.PI !== undefined ? __ink_acc_trgt.PI : null)})();
Tau = (2 * Pi);
Width = 1000;
Height = 1000;
Canvas = bind(document, __Ink_String(`getElementById`))(__Ink_String(`canvas`));
Ctx = bind(Canvas, __Ink_String(`getContext`))(__Ink_String(`2d`));
(() => {let __ink_assgn_trgt = __as_ink_string(Canvas); __is_ink_string(__ink_assgn_trgt) ? __ink_assgn_trgt.assign(width, Width) : (__ink_assgn_trgt.width) = Width; return __ink_assgn_trgt})();
(() => {let __ink_assgn_trgt = __as_ink_string(Canvas); __is_ink_string(__ink_assgn_trgt) ? __ink_assgn_trgt.assign(height, Height) : (__ink_assgn_trgt.height) = Height; return __ink_assgn_trgt})();
sqrt = x => pow(x, 0.50000000);
distanceSq = (a, b) => __as_ink_string(pow(((() => {let __ink_acc_trgt = __as_ink_string(a); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})() - (() => {let __ink_acc_trgt = __as_ink_string(b); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})()), 2) + pow(((() => {let __ink_acc_trgt = __as_ink_string(a); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})() - (() => {let __ink_acc_trgt = __as_ink_string(b); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})()), 2));
distance = (a, b) => sqrt(distanceSq(a, b));
rgb = (r, g, b) => f(__Ink_String(`rgb({{0}}, {{1}}, {{2}})`), [(r * 255.99000000), (g * 255.99000000), (b * 255.99000000)]);
rgba = (r, g, b, a) => f(__Ink_String(`rgb({{0}}, {{1}}, {{2}}, {{3}})`), [(r * 255.99000000), (g * 255.99000000), (b * 255.99000000), a]);
Black = rgb(0, 0, 0);
White = __Ink_String(`rgb(255, 255, 255)`);
coinflip = () => (rand() > 0.50000000);
randCenterBias = (min, max, resolution) => (() => { let parts;  parts = map(range(0, resolution, 1), () => (rand() / resolution)); return __as_ink_string(min + (reduce(parts, (a, b) => __as_ink_string(a + b), 0) * (() => {  return (max - min) })())) })();
randRange = (min, max) => __as_ink_string(min + (rand() * (() => {  return (max - min) })()));
randInt = (min, max) => floor(randRange(min, max));
randColor = () => rgb(rand(), rand(), rand());
randColorAlpha = () => rgba(rand(), rand(), rand(), rand());
randColorGreyscale = () => (() => { let r;  r = rand(); return rgb(r, r, r) })();
randColorGreyscaleAlpha = () => (() => { let r;  r = rand(); return rgba(r, r, r, rand()) })();
choose = list => (() => {let __ink_acc_trgt = __as_ink_string(list); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[floor(randRange(0, len(list)))] || null : (__ink_acc_trgt[floor(randRange(0, len(list)))] !== undefined ? __ink_acc_trgt[floor(randRange(0, len(list)))] : null)})();
setFill = color => (() => {let __ink_assgn_trgt = __as_ink_string(Ctx); __is_ink_string(__ink_assgn_trgt) ? __ink_assgn_trgt.assign(fillStyle, color) : (__ink_assgn_trgt.fillStyle) = color; return __ink_assgn_trgt})();
setLineWidth = width => (() => {let __ink_assgn_trgt = __as_ink_string(Ctx); __is_ink_string(__ink_assgn_trgt) ? __ink_assgn_trgt.assign(lineWidth, width) : (__ink_assgn_trgt.lineWidth) = width; return __ink_assgn_trgt})();
setStroke = color => (() => {let __ink_assgn_trgt = __as_ink_string(Ctx); __is_ink_string(__ink_assgn_trgt) ? __ink_assgn_trgt.assign(strokeStyle, color) : (__ink_assgn_trgt.strokeStyle) = color; return __ink_assgn_trgt})();
fillRect = bind(Ctx, __Ink_String(`fillRect`));
strokeRect = bind(Ctx, __Ink_String(`strokeRect`));
clearRect = bind(Ctx, __Ink_String(`clearRect`));
beginPath = bind(Ctx, __Ink_String(`beginPath`));
moveTo = bind(Ctx, __Ink_String(`moveTo`));
lineTo = bind(Ctx, __Ink_String(`lineTo`));
arc = bind(Ctx, __Ink_String(`arc`));
stroke = bind(Ctx, __Ink_String(`stroke`));
fill = bind(Ctx, __Ink_String(`fill`));
rotate = bind(Ctx, __Ink_String(`rotate`));
translate = bind(Ctx, __Ink_String(`translate`));
drawLine = (start, end) => (() => {  beginPath(); moveTo((() => {let __ink_acc_trgt = __as_ink_string(start); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(), (() => {let __ink_acc_trgt = __as_ink_string(start); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})()); lineTo((() => {let __ink_acc_trgt = __as_ink_string(end); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(), (() => {let __ink_acc_trgt = __as_ink_string(end); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})()); return stroke() })();
drawSinglePath = points => (() => { let start;  beginPath(); start = (() => {let __ink_acc_trgt = __as_ink_string(points); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(); moveTo((() => {let __ink_acc_trgt = __as_ink_string(start); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(), (() => {let __ink_acc_trgt = __as_ink_string(start); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})()); each(slice(points, 1, len(points)), next => lineTo((() => {let __ink_acc_trgt = __as_ink_string(next); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(), (() => {let __ink_acc_trgt = __as_ink_string(next); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})())); return stroke() })();
drawPaths = points => reduce(slice(points, 1, len(points)), (last, next) => (() => {  drawLine(last, next); return next })(), (() => {let __ink_acc_trgt = __as_ink_string(points); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})());
strokeArc = (x, y, r, start, end) => (() => {  beginPath(); arc(x, y, r, start, end); return stroke() })();
fillArc = (x, y, r, start, end) => (() => {  beginPath(); arc(x, y, r, start, end); return fill() })();
strokeCircle = (x, y, r) => strokeArc(x, y, r, 0, Tau);
fillCircle = (x, y, r) => fillArc(x, y, r, 0, Tau);
rotateCanvas = angle => (() => {  translate((Width / 2), (Height / 2)); rotate(angle); return translate((__ink_negate(Width) / 2), (__ink_negate(Height) / 2)) })()

rectGrid = () => (() => {  setFill(__Ink_String(`transparent`)); return each(range(0, Width, 50), x => (() => {  return each(range(0, Height, 50), y => (() => { let radius; let margin;  setLineWidth(randRange(1, 6)); setStroke(randColorGreyscale()); radius = randRange(2, 25); margin = (25 - radius); strokeRect(__as_ink_string(x + margin), __as_ink_string(y + margin), (2 * radius), (2 * radius)); setLineWidth(randRange(1, 6)); setStroke(randColorAlpha()); radius = randRange(2, 25); margin = (25 - radius); return strokeRect(__as_ink_string(x + margin), __as_ink_string(y + margin), (2 * radius), (2 * radius)) })()) })()) })();
diagonals = () => (() => { let randomPoints;  setLineWidth(2); setStroke(rgba(randRange(0.30000000, 0.90000000), randRange(0.30000000, 0.90000000), randRange(0.30000000, 0.90000000), 0.30000000)); randomPoints = map(range(0, 1000, 1), () => [randCenterBias(0, Width, 6), randCenterBias(0, Height, 6)]); return drawPaths(randomPoints) })();
rainbowDiagonals = () => (() => { let randomPoints;  setLineWidth(2); randomPoints = map(range(0, 1000, 1), () => [randCenterBias(0, Width, 5), randCenterBias(0, Height, 5)]); return reduce(slice(randomPoints, 1, len(randomPoints)), (last, next) => (() => {  setStroke(rgba(randRange(0.20000000, 0.80000000), randRange(0.20000000, 0.80000000), randRange(0.20000000, 0.80000000), randRange(0.20000000, 0.60000000))); drawLine(last, next); return next })(), (() => {let __ink_acc_trgt = __as_ink_string(randomPoints); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})()) })();
flowerbed = () => (() => { let Center; let PuffLen; let MaxDist;  Center = [(Width / 2), (Height / 2)]; PuffLen = 36; MaxDist = distance(Center, [40, 40]); return each(range(0, randRange(6, 100), 1), () => (() => { let target; let dist;  target = [randRange(0, Width), randRange(0, Height)]; dist = distance(Center, target); setLineWidth(2); setStroke(rgba(0, 0, 0, (1 - (dist / MaxDist)))); drawLine(Center, target); setLineWidth(5); setStroke(rgba(0.99000000, 0.20000000, 0.20000000, (1 - (dist / MaxDist)))); return each(range(0, 5, 1), () => drawLine(target, [(__as_ink_string((() => {let __ink_acc_trgt = __as_ink_string(target); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})() + randRange(0, PuffLen)) - (PuffLen / 2)), (__as_ink_string((() => {let __ink_acc_trgt = __as_ink_string(target); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})() + randRange(0, PuffLen)) - (PuffLen / 2))])) })()) })();
maze = () => (() => { let CellSize; let jitter;  CellSize = 50; jitter = (() => {  return __ink_match(coinflip(), [[() => (true), () => (() => 2)], [() => (__Ink_Empty), () => (() => randInt(1, 4))]]) })(); setStroke(rgb(0.10000000, 0.10000000, 0.10000000)); return each(range(0, Width, CellSize), x => (() => {  return each(range(0, Height, CellSize), y => (() => {  __ink_match(coinflip(), [[() => (true), () => ((() => {  setLineWidth(1); return drawLine([x, y], [__as_ink_string(x + CellSize), __as_ink_string(y + (CellSize / jitter()))]) })())]]); return __ink_match(coinflip(), [[() => (true), () => ((() => {  setLineWidth(5); return drawLine([__as_ink_string(x + CellSize), y], [x, __as_ink_string(y + CellSize)]) })())]]) })()) })()) })();
radar = () => (() => { let Center; let MaxRadius;  Center = [(Width / 2), (Height / 2)]; MaxRadius = 710; return each(range(10, MaxRadius, 10), r => (() => { let start;  setLineWidth(floor(((() => {  return (1 - (r / MaxRadius)) })() * 12))); start = randRange(0, Tau); strokeArc((() => {let __ink_acc_trgt = __as_ink_string(Center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(), (() => {let __ink_acc_trgt = __as_ink_string(Center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})(), r, start, __as_ink_string(start + randRange(0, (Pi * 0.70000000)))); start = randRange(0, Tau); return strokeArc((() => {let __ink_acc_trgt = __as_ink_string(Center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(), (() => {let __ink_acc_trgt = __as_ink_string(Center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})(), r, start, __as_ink_string(start + randRange(0, (Pi * 0.70000000)))) })()) })();
fans = () => (() => { let MaxRadius; let Center;  Center = [(Width / 2), (Height / 2)]; MaxRadius = 710; setLineWidth(6); return each(range(10, MaxRadius, 6), r => (() => { let start;  setStroke(rgba(rand(), rand(), rand(), (r / MaxRadius))); start = randRange(0, Tau); return strokeArc((() => {let __ink_acc_trgt = __as_ink_string(Center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(), (() => {let __ink_acc_trgt = __as_ink_string(Center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})(), r, start, __as_ink_string(start + randRange(0, (Pi * 1.50000000)))) })()) })();
grid = () => (() => { let MaxRadius; let Center; let CellSize; let HalfCell;  Center = [(Width / 2), (Height / 2)]; CellSize = 50; HalfCell = (CellSize / 2); MaxRadius = 20; return each(range(0, Width, CellSize), x => (() => {  return each(range(0, Height, CellSize), y => __ink_match((rand() > 0.75000000), [[() => (true), () => ((() => { let center; let r;  center = [__as_ink_string(x + HalfCell), __as_ink_string(y + HalfCell)]; setFill(Black); setLineWidth(2); setStroke(Black); r = randRange(0, MaxRadius); strokeCircle((() => {let __ink_acc_trgt = __as_ink_string(center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(), (() => {let __ink_acc_trgt = __as_ink_string(center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})(), r); fillCircle((() => {let __ink_acc_trgt = __as_ink_string(center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(), (() => {let __ink_acc_trgt = __as_ink_string(center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})(), randRange(2, max([(r - 2), 2]))); setLineWidth(1); setStroke(randColorAlpha()); return drawLine(Center, center) })())]])) })()) })();
dots = () => (() => { let Center; let CellSize; let HalfCell; let MaxRadius;  Center = [(Width / 2), (Height / 2)]; CellSize = 50; HalfCell = (CellSize / 2); MaxRadius = 20; return each(range(0, Width, CellSize), x => (() => {  return each(range(0, Height, CellSize), y => (() => { let center; let r;  center = [__as_ink_string(x + HalfCell), __as_ink_string(y + HalfCell)]; r = randRange(0, MaxRadius); setLineWidth(1); strokeCircle((() => {let __ink_acc_trgt = __as_ink_string(center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(), (() => {let __ink_acc_trgt = __as_ink_string(center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})(), r); return fillCircle((() => {let __ink_acc_trgt = __as_ink_string(center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(), (() => {let __ink_acc_trgt = __as_ink_string(center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})(), randRange(2, max([(r - 2), 2]))) })()) })()) })();
waves = () => (() => { let Center; let CellSize; let HalfCell; let MaxRadius;  Center = [(Width / 2), (Height / 2)]; CellSize = 50; HalfCell = (CellSize / 2); MaxRadius = 20; return each(range(0, Width, CellSize), x => (() => {  return each(range(0, Height, CellSize), y => (() => { let center; let r; let arcl; let start;  center = [__as_ink_string(x + HalfCell), __as_ink_string(y + HalfCell)]; r = __as_ink_string(((19 * x) / Width) + 1); arcl = (((() => {  return __as_ink_string(y + CellSize) })() / Height) * Tau); setLineWidth(4); start = randRange(0, Tau); return strokeArc((() => {let __ink_acc_trgt = __as_ink_string(center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(), (() => {let __ink_acc_trgt = __as_ink_string(center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})(), r, start, __as_ink_string(start + arcl)) })()) })()) })();
planets = () => (() => { let Center; let MaxRadius;  Center = [(Width / 2), (Height / 2)]; MaxRadius = 710; setLineWidth(1); fillCircle((() => {let __ink_acc_trgt = __as_ink_string(Center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(), (() => {let __ink_acc_trgt = __as_ink_string(Center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})(), 40); return each(range(80, MaxRadius, 40), r => (() => { let theta; let pos; let start; let end;  start = randRange(0, Tau); end = __as_ink_string(start + randRange(Pi, Tau)); strokeArc((() => {let __ink_acc_trgt = __as_ink_string(Center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(), (() => {let __ink_acc_trgt = __as_ink_string(Center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})(), r, start, end); theta = randRange(start, end); pos = [__as_ink_string((() => {let __ink_acc_trgt = __as_ink_string(Center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})() + (r * cos(theta))), __as_ink_string((() => {let __ink_acc_trgt = __as_ink_string(Center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})() + (r * sin(theta)))]; r = randRange(6, 14); setFill(White); __ink_match(coinflip(), [[() => (true), () => ((() => {  fillCircle((() => {let __ink_acc_trgt = __as_ink_string(pos); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(), (() => {let __ink_acc_trgt = __as_ink_string(pos); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})(), __as_ink_string(r + 16)); return strokeCircle((() => {let __ink_acc_trgt = __as_ink_string(pos); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(), (() => {let __ink_acc_trgt = __as_ink_string(pos); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})(), __as_ink_string(r + 8)) })())], [() => (false), () => (fillCircle((() => {let __ink_acc_trgt = __as_ink_string(pos); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(), (() => {let __ink_acc_trgt = __as_ink_string(pos); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})(), __as_ink_string(r + 8)))]]); setFill(Black); return fillCircle((() => {let __ink_acc_trgt = __as_ink_string(pos); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(), (() => {let __ink_acc_trgt = __as_ink_string(pos); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})(), r) })()) })();
pathfinder = () => (() => { let Center; let Step; let clampOne;  Center = [(Width / 2), (Height / 2)]; Step = 100; clampOne = (x, min, max) => (() => {let __ink_acc_trgt = __as_ink_string(clamp(x, x, min, max)); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[start] || null : (__ink_acc_trgt.start !== undefined ? __ink_acc_trgt.start : null)})(); return reduce(range(0, 700, 1), (last, n) => (() => { let opacity; let next;  opacity = (1 - (n / 500)); setStroke(rgba(0, 0, 0, opacity)); next = (() => {  return __ink_match((n % 2), [[() => (1), () => ([(() => {let __ink_acc_trgt = __as_ink_string(last); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(), clampOne(__as_ink_string((() => {let __ink_acc_trgt = __as_ink_string(last); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})() + randRange(__ink_negate(Step), Step)), 0, 1000)])], [() => (__Ink_Empty), () => ([clampOne(__as_ink_string((() => {let __ink_acc_trgt = __as_ink_string(last); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})() + randRange(__ink_negate(Step), Step)), 0, 1000), (() => {let __ink_acc_trgt = __as_ink_string(last); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})()])]]) })(); drawLine(last, next); __ink_match(coinflip(), [[() => (true), () => ((() => {  setFill(White); fillCircle((() => {let __ink_acc_trgt = __as_ink_string(last); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(), (() => {let __ink_acc_trgt = __as_ink_string(last); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})(), 10); setFill(rgba(0.80000000, 0.10000000, 0.10000000, opacity)); return fillCircle((() => {let __ink_acc_trgt = __as_ink_string(last); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(), (() => {let __ink_acc_trgt = __as_ink_string(last); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})(), 5) })())]]); return next })(), Center) })();
drizzle = () => (() => { let Radius; let MinRadius; let sunlight__ink_qm__;  Radius = 13; MinRadius = 1; sunlight__ink_qm__ = coinflip(); return each(range(0, 1000, 1), () => (() => { let x; let y; let opacity;  x = randRange(Radius, (Width - Radius)); y = randRange(Radius, (Height - Radius)); opacity = pow((y / Height), 1.40000000); __ink_match(coinflip(), [[() => (true), () => (__ink_match(sunlight__ink_qm__, [[() => (true), () => (setFill(rgba(0, 0, 0, opacity)))], [() => (__Ink_Empty), () => (setFill(rgba((0.90000000 * pow((1 - (y / Height)), 0.50000000)), (0.80000000 * pow((1 - (y / Height)), 0.50000000)), (0.30000000 * pow((1 - (y / Height)), 0.50000000)), opacity)))]]))], [() => (__Ink_Empty), () => (setFill(rgba(0, ((0.80000000 * x) / Width), (y / Height), opacity)))]]); return fillCircle(x, y, __as_ink_string(MinRadius + (Radius * (() => {  return (1 - (y / Height)) })()))) })()) })();
pentatone = () => (() => { let Center; let NRects; let RectHeight; let configs;  Center = {x: (Width / 2), y: (Height / 2)}; NRects = choose([16, 25, 50, 100, 200]); RectHeight = (Height / 10); configs = [[rgba(0, 0, 0, 1), (Height / 13)], [rgba(0, 0, 0, 0.30000000), (Height / 7)], [rgba(0, 0, 0, 0.10000000), (Height / 2.50000000)]]; return each(configs, config => (() => { let color; let YVariance;  color = (() => {let __ink_acc_trgt = __as_ink_string(config); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[0] || null : (__ink_acc_trgt[0] !== undefined ? __ink_acc_trgt[0] : null)})(); YVariance = (() => {let __ink_acc_trgt = __as_ink_string(config); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[1] || null : (__ink_acc_trgt[1] !== undefined ? __ink_acc_trgt[1] : null)})(); setFill(color); return reduce(range(0, NRects, 1), lastX => (() => { let nextX; let yVariance;  nextX = __as_ink_string(lastX + (Width / NRects)); yVariance = randRange(__ink_negate(YVariance), YVariance); fillRect(lastX, (__as_ink_string((() => {let __ink_acc_trgt = __as_ink_string(Center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[y] || null : (__ink_acc_trgt.y !== undefined ? __ink_acc_trgt.y : null)})() + yVariance) - (RectHeight / 2)), (Width / NRects), RectHeight); return nextX })(), 0) })()) })();
petals = () => (() => { let Center; let NRects; let AngleVariance;  Center = {x: (Width / 2), y: (Height / 2)}; NRects = choose([10, 16, 25]); AngleVariance = 0.20000000; setFill(rgba(rand(), rand(), rand(), 0.08000000)); return each(range(0, NRects, 1), i => (() => { let radius; let drawFn; let angle;  radius = ((() => {  return (i / NRects) })() * (() => {  return (Width / 2) })()); drawFn = (() => {  return __ink_match(coinflip(), [[() => (true), () => (fillRect)], [() => (__Ink_Empty), () => (strokeRect)]]) })(); angle = randRange(__ink_negate(AngleVariance), AngleVariance); rotateCanvas(angle); drawFn(((() => {let __ink_acc_trgt = __as_ink_string(Center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[x] || null : (__ink_acc_trgt.x !== undefined ? __ink_acc_trgt.x : null)})() - radius), ((() => {let __ink_acc_trgt = __as_ink_string(Center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[y] || null : (__ink_acc_trgt.y !== undefined ? __ink_acc_trgt.y : null)})() - radius), (radius * 2), (radius * 2)); return rotateCanvas(__ink_negate(angle)) })()) })();
minesweeper = () => (() => { let Center; let N; let Radius;  Center = {x: (Width / 2), y: (Height / 2)}; N = choose([30, 50, 75]); Radius = ((Height / N) / 2); setLineWidth(2); return each(range(0, Width, (Width / N)), x => (() => {  return each(range(0, Height, (Height / N)), y => (() => { let center; let xOffset; let yOffset;  center = {x: __as_ink_string(x + ((Width / N) / 2)), y: __as_ink_string(y + ((Height / N) / 2))}; xOffset = ((() => {let __ink_acc_trgt = __as_ink_string(center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[x] || null : (__ink_acc_trgt.x !== undefined ? __ink_acc_trgt.x : null)})() - (() => {let __ink_acc_trgt = __as_ink_string(Center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[x] || null : (__ink_acc_trgt.x !== undefined ? __ink_acc_trgt.x : null)})()); yOffset = ((() => {let __ink_acc_trgt = __as_ink_string(center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[y] || null : (__ink_acc_trgt.y !== undefined ? __ink_acc_trgt.y : null)})() - (() => {let __ink_acc_trgt = __as_ink_string(Center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[y] || null : (__ink_acc_trgt.y !== undefined ? __ink_acc_trgt.y : null)})()); return __ink_match((__as_ink_string((xOffset * xOffset) + (yOffset * yOffset)) < ((Width * Height) / 4)), [[() => (true), () => ((() => { let opacity;  opacity = ((() => {  return __as_ink_string((xOffset * xOffset) + (yOffset * yOffset)) })() / (() => {  return ((Width * Height) / 4) })()); setFill(rgba(0, 0, 0, opacity)); setStroke(rgba(0, 0, 0, (1 - opacity))); return __ink_match(coinflip(), [[() => (true), () => (__ink_match(coinflip(), [[() => (true), () => (fillRect(((() => {let __ink_acc_trgt = __as_ink_string(center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[x] || null : (__ink_acc_trgt.x !== undefined ? __ink_acc_trgt.x : null)})() - Radius), ((() => {let __ink_acc_trgt = __as_ink_string(center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[y] || null : (__ink_acc_trgt.y !== undefined ? __ink_acc_trgt.y : null)})() - Radius), (Radius * 2), (Radius * 2)))]]))], [() => (__Ink_Empty), () => (strokeCircle((() => {let __ink_acc_trgt = __as_ink_string(center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[x] || null : (__ink_acc_trgt.x !== undefined ? __ink_acc_trgt.x : null)})(), (() => {let __ink_acc_trgt = __as_ink_string(center); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[y] || null : (__ink_acc_trgt.y !== undefined ? __ink_acc_trgt.y : null)})(), Radius))]]) })())]]) })()) })()) })();
options = [rectGrid, diagonals, rainbowDiagonals, flowerbed, maze, radar, fans, grid, dots, waves, planets, pathfinder, drizzle, pentatone, petals, minesweeper];
generate = () => (() => {  clearRect(0, 0, Width, Height); setFill(White); fillRect(0, 0, Width, Height); setFill(Black); setStroke(Black); setLineWidth(1); return (() => {  return (() => {let __ink_acc_trgt = __as_ink_string(options); return __is_ink_string(__ink_acc_trgt) ? __ink_acc_trgt.valueOf()[randInt(0, len(options))] || null : (__ink_acc_trgt[randInt(0, len(options))] !== undefined ? __ink_acc_trgt[randInt(0, len(options))] : null)})() })()() })();
generate()

